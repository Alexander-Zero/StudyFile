# 单机高并发

### 1.线程相关概念

##### 创建线程的方式(2种/3种)

​	 实现Runnable和继承Thread/或通过线程池来创建 Excecutors.newCachedPool()

```java
//静态方法
Thread.sleep(long time);//静态方法调用, 使线程切换到TimeWaiting状态
Thread.yield();//静态方法调用,使正在调用的线程让出cpu资源(让出后所有线程竞争cpu资源)
//实例方法(使用方法 ??? 调用wait()报错???)
t1.start();//执行线程,使线程切换到Runnable状态(包含Ready和Running状态)
t1.join();//让出CPU资源,让t1线程先执行完.
???????????????????????????????????????????????
t1.wait(long time);//实例方法,会释放锁资源,使线程切换到Waiting状态或者TimeWaiting状态,取决于参数
t1.notify();//使t1线程处于Ready状态???能否唤醒阻塞的线程
t1.notifyAll();//使所有等待处于Ready状态???

```

##### 线程状态,6/7种

![image-20201116224400140](images/image-20201116224400140.png)



JVM内存模型,对象实例创建于heap中, 线程要使用需copy修改值后在copy回去

![image-20201120214655485](images/image-20201120214655485.png) 

### 2. volatile 关键字

##### 线程可见性

硬件层面: MESI(缓存一致性协议)来保证?? 待补充

##### 禁止指令重排序

double check lock来保证单例 需加 volatile关键字. 因instance = new Instance()可以别分成多个指令(1.分配内存, 2.初始化值, 3. 引用赋值),只要完成 引用赋值 判空时 就不为空, 但指令重排序后可能存在两种结果 1->2->3 或 1->3->2 , 所以存在完成引用赋值后但未被赋初值. 

为什么要指令重排序? 多条指令可能并发执行,为提高执行效率.

在cpu原语上时通过读屏障(loadfence)和写屏障(storefence)来实现????

### 3. Synchronized 

锁对象实现锁定有对象头中的markword来实现的.  synchronized 保证 原子性 , 可见性 和 禁止指令重排

synchronized -> 锁升级(1.5之后):  偏向锁(MarkWord中记录线程ID)->自旋锁(原地等待,占用CPU)->重量级锁=

synchorized锁优化

1.锁细化 , synchorized锁住的代码块越少越好. 

2.锁粗化, 若太多细化的锁,导致争用频繁,不如将锁的范围扩大,只使用一把锁.

3.引用类型的锁对象要防止引用发生变化, 用作锁的对象最好都加上final修饰,防止引用发生改变.

4.锁不应该时String类型, 字符串常量池

5.调用wait() 及抛出异常,将释放锁

##### 自旋锁CAS

 compare and swap(set),乐观锁, 自旋锁, 无锁优化. 位于JUC(java.util.concurrent)包下.

ReentrantLock及 atomicXXX, LongAdder等.实现大致如下,具体见Unsafe类(可直接操纵内存,如分配内存和释放内存方法).`

```java
cas(value,expected,new){
	if(value==expected){
		value==new //备注: CPU原语支持,可保证赋新值时读取到旧值不一致问题
	}
}
```

可能存在ABA问题(对基础类型无影响,对引用类型可能有影响,引用类型引用未改变,但该对象中的其他值已改变).处理方式时加版本号,见AtomicStampedReference类.

自旋锁(Atomic及Lock)及系统锁使用场景(自旋锁占CPU资源)

锁定代码执行时间短,线程数少 -> 自旋锁 , 执行时间长, 线程数多 -> 系统锁  

### 4. ReentrantLock 重入锁

Synchronized 与ReentrantLock区别: ReentrantLock多了很多功能,如

```
tryLock(),
tryLock(long time,TimeUnit unit); 
lock.lockInterruptibly()
Condition condition = lock.newCondition();
```

​	



### 5.AtomicXXX , LongAdder, DoubleAdder

AtomicXXX自旋锁, LongAdder 分段锁(相当于讲有多个AtomicXXX, 分别自旋, 然后将多个Atomic的值相加)









