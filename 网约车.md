## project

注意: trade off, 任何技术都有优缺点,



### 项目介绍

技术架构图

整体架构图

时序图



### eureka

注意: 外部框架引用三部曲  1: POM 2.config 3.@EnableXXX

注意: 源码查看方式, 可看日志文件 ????



优化: 

> ```yml
> #EurekaServer
> #自我保护:
> eureka.server.enable-self-preservation=true //注册服务少时关闭自我保护 或 降低阈
> eureka.server.renewal.percent.threshold=0.85 //注册服务多时开启自我保护 并 提高阈值
> #缓存同步
> eureka.server.use-read-only-response-cache=false //不启用ReadOnlyMap
> eureka.server.response-cache-update-interval-ms=30 //ReadOnly同步时间间隔 
> #剔除任务
> eureka.server.eviction-interval-timer-in-ms= 1000 //将间隔时间设小一点,快速下线
> 
> #EurekaClient
> #拉取间隔时间
> eureka.client.registry-fetch-interval-seconds=30
> #续约间隔时间
> eureka.instance.lease-renewal-interval-in-seconds=30
> #打乱地址,不超过3个
> eureka.client.service-url.defaultZone=url1,url2,url3
> ```
>
>  1,目的: 减少服务上下线延时
>
>  2,先停服后下线, 避免自动续约
>
> 
>
>  源码: 
>
> Timer -> evitTask() 时间间隔 
>
> ```
> 使用ScheduledExecutorService代替Timer吧
> 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题
> ```
>
> evit(){
>
> ​	可剔除数 =  注册数 - 注册数 * 心跳阈值
>
> }



#### eureka server:

启动后 拉取其他节点的, 并开启剔除定时任务

注册: register (ApplicationResource)

续约: renew 

集群同步:  replicateToPeers  , 每次注册和续约都要调用该方法

拉取:  增量拉取(all_apps_delta), 全量拉取(apps_all)

下线: cancel , 调用internalCancel

剔除 : evit 定时任务，调用internalCancel



区域设置: 优先拉取同区域的服务

```
eureka: 
	client:
    	region: bj
        availability-zones:
          bj: z1,z2
        service-url:
          z1: http://localhost:7911/eureka/,http://localhost:7912/eureka/
          z2: http://localhost:7921/eureka/,http://localhost:7922/eureka/
        prefer-same-zone-eureka: true
```

CAP => AP  保证AP, 

1.三级缓存。

2.从其他peer拉取注册表。peer。int registryCount = this.registry.syncUp()，没有满足C的地方。

3.P：网络不好的情况下，还是可以拉取到注册表进行调用的。服务还可以调用。





#### eureka client

client 是与server交互的配置, instance是自身的配置

注册

续约

拉取

下线

#### 服务测算

client 需要拉取 和 续约

每天服务数 = (每分钟续约数 + 每分钟拉取数 ) * 60 * 24 * 服务数

每天几十W没问题. 



### 灰度发布

### 网关

### 分布式事务

#### 2pc

#### 3pc

#### lcn

#### tcc

#### seata

#### 消息队列+事务+事务表

#### 消息队列+可靠消息

#### 事务消息

#### 最大努力通知

### 分布式锁

#### mysql主键冲突

#### redis

#### redisson

#### 红锁

#### etcd

#### zookeeper





eureka服务优化:



spring factory

@conditionalOnBean (Class), 又clazz的bean就配置生效









### 注解

```java
@PropertySource("classpath:/eureka/server.properties")  //把配置文件加载到Enviroment, 与@Configuration一起使用
@ConfigurationProperties("eureka.dashboard")  //绑定属性到类上,单独使用不会注册到IOC, 需配合@Component 或 @EnableConfigurationProperties
@EnableConfigurationProperties({ EurekaDashboardProperties.class}) //将@ConfigurationProperties的属性注册到IOC

@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)  //Ioc有Marker实例, 配置文件生效
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = "eureka.dashboard", name = "enabled", matchIfMissing = true)

    
@AutoConfigureBefore 
@AutoConfigureAfter

```

spring.factories

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxx
org.springframework.cloud.bootstrap.BootstrapConfiguration=xxx
org.springframework.boot.Bootstrapper=xx
```