## project

注意: trade off, 任何技术都有优缺点,



### 项目介绍

技术架构图

整体架构图

时序图



### eureka

注意: 外部框架引用三部曲  1: POM 2.config 3.@EnableXXX

注意: 源码查看方式, 可看日志文件 ????



优化: 

> ```yml
> #EurekaServer
> #自我保护:
> eureka.server.enable-self-preservation=true //注册服务少时关闭自我保护 或 降低阈
> eureka.server.renewal.percent.threshold=0.85 //注册服务多时开启自我保护 并 提高阈值
> #缓存同步
> eureka.server.use-read-only-response-cache=false //不启用ReadOnlyMap
> eureka.server.response-cache-update-interval-ms=30 //ReadOnly同步时间间隔 
> #剔除任务
> eureka.server.eviction-interval-timer-in-ms= 1000 //将间隔时间设小一点,快速下线
> 
> #EurekaClient
> #拉取间隔时间
> eureka.client.registry-fetch-interval-seconds=30
> #续约间隔时间
> eureka.instance.lease-renewal-interval-in-seconds=30
> #打乱地址,不超过3个
> eureka.client.service-url.defaultZone=url1,url2,url3
> ```
>
>  1,目的: 减少服务上下线延时
>
>  2,先停服后下线, 避免自动续约
>
> 
>
>  源码: 
>
> Timer -> evitTask() 时间间隔 
>
> ```
> 使用ScheduledExecutorService代替Timer吧
> 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题
> ```
>
> evit(){
>
> ​	可剔除数 =  注册数 - 注册数 * 心跳阈值
>
> }



#### eureka server:

启动后 拉取其他节点的, 并开启剔除定时任务

注册: register (ApplicationResource)

续约: renew 

集群同步:  replicateToPeers  , 每次注册和续约都要调用该方法

拉取:  增量拉取(all_apps_delta), 全量拉取(apps_all)

下线: cancel , 调用internalCancel

剔除 : evit 定时任务，调用internalCancel



区域设置: 优先拉取同区域的服务

```
eureka: 
	client:
    	region: bj
        availability-zones:
          bj: z1,z2
        service-url:
          z1: http://localhost:7911/eureka/,http://localhost:7912/eureka/
          z2: http://localhost:7921/eureka/,http://localhost:7922/eureka/
        prefer-same-zone-eureka: true
```

CAP => AP  保证AP, 

1.三级缓存。

2.从其他peer拉取注册表。peer。int registryCount = this.registry.syncUp()，没有满足C的地方。

3.P：网络不好的情况下，还是可以拉取到注册表进行调用的。服务还可以调用。





#### eureka client

client 是与server交互的配置, instance是自身的配置

注册

续约

拉取

下线

#### 服务测算

client 需要拉取 和 续约

每天服务数 = (每分钟续约数 + 每分钟拉取数 ) * 60 * 24 * 服务数

每天几十W没问题. 



### 灰度发布

#### 蓝绿发布

版本１，版本２共存，版本２稳定后删除版本１，不稳定回滚版本１.　（版本１与２服务器数量相同）

优点：不停服，

缺点：资源浪费，需要多一倍的服务器，一段时间内新老服务共存



#### 滚动发布

蓝绿发布的改进，例３台版本１，１台版本２，　１台　版本１＝＞版本２，　直至全部为版本２

优点：不停服，较蓝绿节省部分服务器

缺点：一段时间内新老服务共存

#### 灰度发布

蓝绿发布和滚动发布在一定时间内新老服务完全共存，若有bug, 会影响现有业务

灰度发布 可 动态制定路由规则, 可实现精确 将部分用户 路由到 旧版本. 逐渐扩大 用户范围, 带新版本无误后全部更新至新版本

A/B Test

##### 网关   =>  服务

**重要** 若Instance元数据中没有相应值会报错

pom

```
<dependency>
    <groupId>io.jmnarloch</groupId>
    <artifactId>ribbon-discovery-filter-spring-cloud-starter</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>

```

Filter

```
@Component
public class GrayFilter extends ZuulFilter {
    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext currentContext = RequestContext.getCurrentContext();
        HttpServletRequest request = currentContext.getRequest();
        String userId = request.getHeader("userId");
		//查库:  用户信息 + 路由规则表 => 具体服务
		RibbonFilterContextHolder.clearCurrentContext();
        if ("1".equals(userId)) {
            RibbonFilterContextHolder.getCurrentContext().add("myName", "zero");
        } else {
            RibbonFilterContextHolder.getCurrentContext().add("myName", "alex");
        }
        return null;
    }
}
```

动态更新 service metadata

>1, 查看信息  http://localhost:7900/eureka/apps/api-auth  或   http://localhost:7900/eureka/apps
>
>2,  更新元数据  PUT /eureka/apps/**appID**/**instanceID**/metadata?key=value



##### 服务A => 服务B







### 网关

### 分布式事务

#### 2pc

#### 3pc

#### lcn

#### tcc

#### seata

#### 消息队列+事务+事务表

#### 消息队列+可靠消息

#### 事务消息

#### 最大努力通知

### 分布式锁

#### mysql主键冲突

#### redis

#### redisson

#### 红锁

#### etcd

#### zookeeper





eureka服务优化:



spring factory

@conditionalOnBean (Class), 又clazz的bean就配置生效









### 注解

```java
@PropertySource("classpath:/eureka/server.properties")  //把配置文件加载到Enviroment, 与@Configuration一起使用
@ConfigurationProperties("eureka.dashboard")  //绑定属性到类上,单独使用不会注册到IOC, 需配合@Component 或 @EnableConfigurationProperties
@EnableConfigurationProperties({ EurekaDashboardProperties.class}) //将@ConfigurationProperties的属性注册到IOC

@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)  //Ioc有Marker实例, 配置文件生效
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = "eureka.dashboard", name = "enabled", matchIfMissing = true)

    
@AutoConfigureBefore 
@AutoConfigureAfter

```

spring.factories

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=xxx
org.springframework.cloud.bootstrap.BootstrapConfiguration=xxx
org.springframework.boot.Bootstrapper=xx
```